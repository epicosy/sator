from typing import List

from sator.core.models.product import AffectedProducts
from sator.core.models.vulnerability.metadata import VulnerabilityMetadata
from sator.core.models.vulnerability.description import VulnerabilityDescription
from sator.core.models.product.locator import ProductLocator
from sator.core.models.vulnerability.locator import VulnerabilityLocator

from sator.core.ports.driven.gateways.oss import OSSGatewayPort
from sator.core.ports.driven.persistence.storage import StoragePersistencePort
from sator.core.ports.driven.repositories.vulnerability import VulnerabilityRepositoryPort
from sator.core.ports.driving.resolution.vulnerability import VulnerabilityResolutionPort


class VulnerabilityResolutionUseCase(VulnerabilityResolutionPort):
    def __init__(self, repository_ports: List[VulnerabilityRepositoryPort], storage_port: StoragePersistencePort,
                 oss_port: OSSGatewayPort):
        self.repository_ports = repository_ports
        self.storage_port = storage_port
        self.oss_port = oss_port

    def get_metadata(self, vulnerability_id: str) -> VulnerabilityMetadata | None:
        vulnerability = self.storage_port.load(VulnerabilityMetadata, vulnerability_id)

        if vulnerability and isinstance(vulnerability, VulnerabilityMetadata):
            return vulnerability

        #  TODO: should consider all metadata and not just the first one
        for port in self.repository_ports:
            vulnerability = port.get_metadata(vulnerability_id)
            self.storage_port.save(vulnerability, vulnerability_id)

            if vulnerability:
                return vulnerability

        return None

    def get_description(self, vulnerability_id: str) -> VulnerabilityDescription | None:
        description = self.storage_port.load(VulnerabilityDescription, vulnerability_id)

        if description:
            return description

        #  TODO: should consider all descriptions and not just the first one
        for port in self.repository_ports:
            description = port.get_description(vulnerability_id)

            if description:
                self.storage_port.save(description, vulnerability_id)

                return description

        return None

    def get_locator(self, vulnerability_id: str) -> VulnerabilityLocator | None:
        locator = self.storage_port.load(VulnerabilityLocator, vulnerability_id)

        if locator:
            return locator

        visited = set()

        vulnerability = self.storage_port.load(VulnerabilityMetadata, vulnerability_id)

        if vulnerability:
            for repository in self.repository_ports:
                for reference in repository.get_references(vulnerability):
                    if reference in visited:
                        continue

                    visited.add(reference)
                    commit_id, repo_id, commit_sha = self.oss_port.get_ids_from_url(reference)

                    if commit_sha:
                        locator = VulnerabilityLocator(vulnerability_id=vulnerability_id, repository_id=repo_id,
                                                       commit_sha=commit_sha)
                        self.storage_port.save(locator, vulnerability_id)
                        return locator

        # if no commits are found, fetch the last n commits before the vulnerability was published
        affected_products = self.storage_port.load(AffectedProducts, vulnerability_id)

        if affected_products:
            # TODO: This part should probably be moved into a separate port
            for product in affected_products:
                product_key = f"{product.vendor} {product.name}"
                product_locator = self.storage_port.load(ProductLocator, product_key)

                if product_locator:
                    # TODO: should include versions and fetch all commits between the reported and published date
                    commits = self.oss_port.search(
                        repo_id=product_locator.repository_id,
                        start_date=vulnerability.reported_date,
                        end_date=vulnerability.published_date,
                        n=1
                    )

                    for commit in commits:
                        locator = VulnerabilityLocator(vulnerability_id=vulnerability_id,
                                                       repository_id=product_locator.repository_id,
                                                       commit_sha=commit)
                        self.storage_port.save(locator, vulnerability_id)
                        return locator

        return None

    def get_affected_products(self, vulnerability_id: str) -> AffectedProducts | None:
        affected_products = self.storage_port.load(AffectedProducts, vulnerability_id)

        if affected_products:
            return affected_products

        vulnerability = self.storage_port.load(VulnerabilityMetadata, vulnerability_id)

        if vulnerability:
            products = [_p for port in self.repository_ports for _p in port.get_affected_products(vulnerability)]

            if products:
                affected_products = AffectedProducts(vulnerability_id=vulnerability_id, products=products)
                self.storage_port.save(affected_products, vulnerability_id)

                return affected_products

        return None

    def get_vulnerabilities(self):
        # TODO: Implement this method
        pass
